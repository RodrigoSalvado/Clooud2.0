name: Deploy Bicep + Web App e Function App

on:
  push:
    branches:
      - main
      - master

permissions:
  id-token: write
  contents: read

jobs:
  deploy:
    runs-on: ubuntu-latest

    env:
      COSMOS_ACCOUNT_NAME: 'cosmosdbminiprojeto'
      COSMOS_THROUGHPUT: '400'
      FUNCTIONAPP_NAME: 'func-rodrig0salv'
      RG: 'MiniProjetoCloud2.0'
      TARGET_LOCATION: 'francecentral'
      WEBAPP_NAME: 'minhaapp-rodrig0salv'
      AZURE_FUNCTIONAPP_PACKAGE_PATH: './redditIngestFunc'
      STORAGE_ACCOUNT_NAME: 'miniprojetostorage20'
      CONTAINER_NAME: 'reddit-posts'

    steps:
      - name: Checkout do repositório
        uses: actions/checkout@v4

      - name: Login no Azure via OIDC
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Instalar jq (no runner)
        run: |
          if ! command -v jq &>/dev/null; then
            sudo apt-get update
            sudo apt-get install -y jq
          fi

      - name: (Re)Criar Resource Group se não existir
        run: |
          EXISTE_RG_JSON=$(az group show --name "$RG" -o json 2>/dev/null || echo "")
          if [ -z "$EXISTE_RG_JSON" ]; then
            echo "Criando Resource Group '$RG' em $TARGET_LOCATION..."
            az group create --name "$RG" --location "$TARGET_LOCATION"
          else
            echo "Resource Group '$RG' já existe em $TARGET_LOCATION. Continuando."
          fi

      - name: Validar templates Bicep localmente
        run: |
          az bicep install || true
          az bicep build --file templates/resource-group.bicep
          az bicep build --file templates/storage-account.bicep
          az bicep build --file templates/cosmosdb.bicep
          az bicep build --file templates/app-service-plan.bicep
          az bicep build --file templates/web-app.bicep
          az bicep build --file templates/function-app.bicep

      - name: Deploy Storage Account + Container
        uses: azure/cli@v1
        with:
          inlineScript: |
            DEPLOY_NAME="deploy-storage-$(date +%s)"
            echo "Deploy Storage Account via Bicep: $DEPLOY_NAME"
            az deployment group create \
              --name "$DEPLOY_NAME" \
              --resource-group "$RG" \
              --template-file templates/storage-account.bicep \
              --parameters \
                storageAccountName="${STORAGE_ACCOUNT_NAME}" \
                containerName="${CONTAINER_NAME}" \
                enableBlobVersioning=true \
                blobSoftDeleteDays=7 \
              --only-show-errors
            echo "Storage Account deploy concluído: $DEPLOY_NAME"

      - name: Deploy CosmosDB (se não existir)
        uses: azure/cli@v1
        with:
          inlineScript: |
            ACCOUNT_NAME="${COSMOS_ACCOUNT_NAME}"
            if [ -z "$ACCOUNT_NAME" ]; then
              echo "Variável COSMOS_ACCOUNT_NAME vazia: pulando Cosmos DB."
              exit 0
            fi

            if az cosmosdb show --name "$ACCOUNT_NAME" --resource-group "$RG" &>/dev/null; then
              echo "Conta Cosmos DB '$ACCOUNT_NAME' já existe em RG '$RG'. Pulando deploy."
            else
              echo "Conta Cosmos DB '$ACCOUNT_NAME' NÃO existe. Realizando deploy em $TARGET_LOCATION..."
              DEPLOY_NAME="deploy-cosmos-$(date +%s)"
              az deployment group create \
                --name "$DEPLOY_NAME" \
                --resource-group "$RG" \
                --template-file templates/cosmosdb.bicep \
                --parameters \
                  cosmosAccountName="$ACCOUNT_NAME" \
                  cosmosLocation="$TARGET_LOCATION" \
                  cosmosDatabaseName='RedditApp' \
                  cosmosContainerName='posts' \
                  # Ajuste partitionKeyPath para '/subreddit' pois seu código usa partition_key=subreddit
                  cosmosPartitionKeyPath='/subreddit' \
                  cosmosThroughput=${COSMOS_THROUGHPUT} \
                --only-show-errors
              echo "Deploy Cosmos concluído: $DEPLOY_NAME"
            fi

      - name: Deploy App Service Plan para Web App
        uses: azure/cli@v1
        with:
          inlineScript: |
            DEPLOY_NAME="deploy-asp-web-$(date +%s)"
            echo "Deploy App Service Plan: $DEPLOY_NAME"
            az deployment group create \
              --name "$DEPLOY_NAME" \
              --resource-group "$RG" \
              --template-file templates/app-service-plan.bicep \
              --parameters \
                planName='ASP-MiniProjetoCloud2.0' \
                skuTier='Basic' \
                skuName='B2' \
                capacity=1 \
                isLinux=true \
                location="$TARGET_LOCATION" \
              --only-show-errors
            echo "App Service Plan deploy concluído: $DEPLOY_NAME"

      - name: Gerar SAS token e CONTAINER_ENDPOINT_SAS completo
        id: gen_sas
        uses: azure/cli@v1
        with:
          inlineScript: |
            ACCOUNT_NAME="${STORAGE_ACCOUNT_NAME}"
            CONTAINER_NAME="${CONTAINER_NAME}"
            # Gera token SAS com permissão de leitura, escrita, delete etc.
            # Ajuste validade para 30 dias (pode aumentar ou automatizar rotação conforme política)
            EXPIRY=$(date -u -d "30 days" '+%Y-%m-%dT%H:%MZ')
            ACCOUNT_KEY=$(az storage account keys list \
              --account-name "$ACCOUNT_NAME" \
              --resource-group "$RG" \
              --query "[0].value" -o tsv)
            sasToken=$(az storage container generate-sas \
              --account-name "$ACCOUNT_NAME" \
              --account-key "$ACCOUNT_KEY" \
              --name "$CONTAINER_NAME" \
              --permissions raclwd \
              --expiry "$EXPIRY" \
              --https-only \
              -o tsv)
            blobEndpoint=$(az storage account show \
              --name "$ACCOUNT_NAME" \
              --query "primaryEndpoints.blob" -o tsv)
            blobEndpoint=${blobEndpoint%/}
            fullSasUrl="${blobEndpoint}/${CONTAINER_NAME}?${sasToken}"
            echo "SAS_TOKEN=$sasToken" >> $GITHUB_OUTPUT
            echo "CONTAINER_ENDPOINT_SAS=$fullSasUrl" >> $GITHUB_OUTPUT
            # DEBUG:
            echo "DEBUG: fullSasUrl = $fullSasUrl"

      - name: Login Docker Hub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Build da imagem Docker da Web App
        run: |
          echo "A construir a imagem Docker: rodrig0salv/minha-app:latest"
          docker build -t rodrig0salv/minha-app:latest ./web-app

      - name: Push da imagem Docker para Docker Hub
        run: |
          echo "A enviar a imagem Docker para Docker Hub"
          docker push rodrig0salv/minha-app:latest

      - name: Deploy Function App via Bicep (template)
        uses: azure/cli@v1
        with:
          inlineScript: |
            echo "Deploy Function App ($FUNCTIONAPP_NAME) via Bicep..."
            az deployment group create \
              --name "deploy-funcapp-$(date +%s)" \
              --resource-group "$RG" \
              --template-file templates/function-app.bicep \
              --parameters \
                functionAppName="$FUNCTIONAPP_NAME" \
                planName="ASP-MiniProjetoCloud2.0" \
                storageAccountName="${STORAGE_ACCOUNT_NAME}" \
                cosmosAccountName="${COSMOS_ACCOUNT_NAME}" \
                cosmosDatabaseName="RedditApp" \
                cosmosContainerName="posts" \
                redditUser="${{ secrets.REDDIT_USER }}" \
                redditPassword="${{ secrets.REDDIT_PASSWORD }}" \
                clientIdValue="${{ secrets.CLIENT_ID }}" \
                secretValue="${{ secrets.CLIENT_SECRET }}" \
                translatorEndpoint="" \
                translatorKey="" \
              --only-show-errors
            echo "Function App deployment via Bicep concluído."

      - name: Empacotar código da Function App para Zip Deploy
        run: |
          echo "Empacotando código das Azure Functions..."
          cd "${AZURE_FUNCTIONAPP_PACKAGE_PATH}"
          # Assumindo que:
          # - host.json está nesta pasta
          # - pastas SearchFunction/, GetPostsFunction/ estão presentes
          # - requirements.txt está na raiz aqui
          # Vamos usar instalação de dependências no Azure, então não vendorar localmente.
          # (Opcionalmente, com vendoring, você criaria .python_packages e pip install -r requirements.txt --target .python_packages/lib/site-packages)
          # Mas aqui deixamos que o Azure instale do requirements.txt, então apenas criamos zip com código fonte.
          zip -r ../funcapp.zip .
          echo "Conteúdo do zip:"
          unzip -l ../funcapp.zip

      - name: Deploy Function App via Zip Deploy
        uses: azure/cli@v1
        with:
          inlineScript: |
            echo "Deploy Function App ($FUNCTIONAPP_NAME) via Zip Deploy..."
            # Usa run-from-package para Python:
            az functionapp config appsettings set \
              --resource-group "$RG" \
              --name "$FUNCTIONAPP_NAME" \
              --settings FUNCTIONS_WORKER_RUNTIME=python WEBSITE_RUN_FROM_PACKAGE=1 SCM_DO_BUILD_DURING_DEPLOYMENT=true \
              --only-show-errors
            az functionapp deployment source config-zip \
              --resource-group "$RG" \
              --name "$FUNCTIONAPP_NAME" \
              --src "$GITHUB_WORKSPACE/funcapp.zip" \
              --only-show-errors
            echo "Zip Deploy da Function concluído."

      - name: Aguardar indexação e obter master key da Function App
        uses: azure/cli@v1
        with:
          inlineScript: |
            echo "Aguardando alguns segundos para indexação das funções..."
            sleep 15
            echo "Obtendo master key da Function App '$FUNCTIONAPP_NAME'..."
            MASTER_KEY=$(az functionapp keys list \
              --resource-group "$RG" \
              --name "$FUNCTIONAPP_NAME" \
              --query "masterKey" -o tsv)
            if [ -z "$MASTER_KEY" ]; then
              echo "Erro: não conseguiu obter master key da Function App."
              exit 1
            fi
            echo "FUNCTION_KEY=$MASTER_KEY" >> $GITHUB_OUTPUT

      - name: Construir FUNCTION URLs
        id: set_function_url
        run: |
          # As rotas definidas em function.json devem ser "route": "search" e "route": "getposts"
          echo "Montando URLs das funções..."
          FUNCTION_URL_FULL="https://${FUNCTIONAPP_NAME}.azurewebsites.net/api/search?code=${{ steps.get_function_key.outputs.FUNCTION_KEY }}"
          GET_POSTS_FUNCTION_URL="https://${FUNCTIONAPP_NAME}.azurewebsites.net/api/getposts?code=${{ steps.get_function_key.outputs.FUNCTION_KEY }}"
          echo "FUNCTION_URL_FULL=$FUNCTION_URL_FULL" >> $GITHUB_OUTPUT
          echo "GET_POSTS_FUNCTION_URL=$GET_POSTS_FUNCTION_URL" >> $GITHUB_OUTPUT
          echo "DEBUG: FUNCTION_URL_FULL = $FUNCTION_URL_FULL"
          echo "DEBUG: GET_POSTS_FUNCTION_URL = $GET_POSTS_FUNCTION_URL"

      - name: Deploy Web App com Function URL e CONTAINER_ENDPOINT_SAS
        uses: azure/cli@v1
        with:
          inlineScript: |
            SAS_FULL="${{ steps.gen_sas.outputs.CONTAINER_ENDPOINT_SAS }}"
            FUNCTION_URL_FULL="${{ steps.set_function_url.outputs.FUNCTION_URL_FULL }}"
            GET_POSTS_FUNCTION_URL="${{ steps.set_function_url.outputs.GET_POSTS_FUNCTION_URL }}"
            echo "DEBUG: SAS_FULL para deploy do Web App: $SAS_FULL"
            echo "DEBUG: FUNCTION_URL_FULL: $FUNCTION_URL_FULL"
            echo "DEBUG: GET_POSTS_FUNCTION_URL: $GET_POSTS_FUNCTION_URL"
            # Define App Settings no Web App:
            az webapp config appsettings set \
              --resource-group "$RG" \
              --name "$WEBAPP_NAME" \
              --settings \
                CONTAINER_ENDPOINT_SAS="$SAS_FULL" \
                FUNCTION_URL="$FUNCTION_URL_FULL" \
                GET_POSTS_FUNCTION_URL="$GET_POSTS_FUNCTION_URL" \
              --only-show-errors
            # Deploy via Bicep do Web App (imagem Docker), incluindo referências:
            echo "Iniciando deploy Web App ($WEBAPP_NAME) via Bicep..."
            az deployment group create \
              --name "deploy-webapp-$(date +%s)" \
              --resource-group "$RG" \
              --template-file templates/web-app.bicep \
              --parameters \
                webAppName="$WEBAPP_NAME" \
                planName="ASP-MiniProjetoCloud2.0" \
                imageName="rodrig0salv/minha-app:latest" \
                # Se precisar de Container Registry credenciais, ajuste; se imagem pública, pode deixar vazio:
                containerRegistryUrl="" \
                containerRegistryUsername="" \
                containerRegistryPassword="" \
                storageAccountName="${STORAGE_ACCOUNT_NAME}" \
                containerName="${CONTAINER_NAME}" \
                containerSasToken="${{ steps.gen_sas.outputs.SAS_TOKEN }}" \
                functionUrl="$FUNCTION_URL_FULL" \
                functionGetPostsUrl="$GET_POSTS_FUNCTION_URL" \
                containerEndpointSas="$SAS_FULL" \
              --only-show-errors
            echo "Web App deployment concluído."

      - name: Reiniciar Web App e Function App após deploy
        uses: azure/cli@v1
        with:
          inlineScript: |
            echo "Reiniciando Web App e Function App..."
            az webapp restart --resource-group "$RG" --name "$WEBAPP_NAME" --only-show-errors
            az functionapp restart --resource-group "$RG" --name "$FUNCTIONAPP_NAME" --only-show-errors

      - name: Mostrar outputs finais Web + Function e App Settings
        uses: azure/cli@v1
        with:
          inlineScript: |
            echo "=== App Settings do Web App após deploy ==="
            az webapp config appsettings list --resource-group "$RG" --name "$WEBAPP_NAME" -o table
            echo "=== App Settings do Function App após deploy ==="
            az functionapp config appsettings list --resource-group "$RG" --name "$FUNCTIONAPP_NAME" -o table
            echo "=== Funções disponíveis na Function App ==="
            func azure functionapp list-functions "$FUNCTIONAPP_NAME" --resource-group "$RG"

